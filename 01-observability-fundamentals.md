# What is Observability?
- Observability is the ability to understand and measure the state of a system based on the data generated by the system.
- Observability allows you to generate actionable outputs from unexpected scenarios in dynamic environments.
- By implementing observability within your applications and infrastructure, you gain deep insights into your system's internal workings:
- Observability will help:
    1. Give better insight into the internal workings of a system/application
    2. Speed up troubleshooting
    3. Detect hard to catch problems
    4. Monitor performance of an application
    5. Improve cross-team collaboration
- When it comes to troubleshooting issues, we need more information than just what is wrong.
- We need to know why our application entered a specific state, what component is responsible and how we can avoid it in the future.
    - Why are error rates rising
    - Why is there high latency
    - Why are services timing out
- Observability gives you the flexibility to understand unpredictable events.
- Observability achieves this by leveraging three critical pillars: **logging**, **tracing**, and **metrics**.

---

# 3 pillars of Observability
## Logging
- Logs are records of events that provide detailed information about system operations. 
- Each log entry typically features a timestamp marking when the event occurred and a descriptive message. 
- Logs are universally generated by operating systems, applications, and databases, serving as the first data point in your observability strategy.
- For example, consider the following log entries:
```bash
Oct 26 19:35:00 ub1 kernel: [37510.942568] e1000: enp0s3 NIC Link is Down
Oct 26 19:35:00 ub1 kernel: [37510.942697] e1000 0000:00:03.0 enp0s3: Reset adapter
Oct 26 19:35:03 ub1 kernel: [37513.054072] e1000: enp0s3 NIC Link is Up 1000 Mbps Full Duplex, Flow Control: RX
```
- While logs provide valuable contextual data, their high verbosity and the intertwining of processes across multiple systems can complicate the process of pinpointing issues during an outage.

## Tracing
- Tracing enables you to follow individual requests as they pass through various systems and services. 
- Each request is assigned a unique trace ID, which allows you to visualize its journey across the entire application landscape. - Within each trace, individual eventsâ€”called **spans** - represent interactions at different interfaces or services.
- Each span records details such as start time, duration, and a parent ID that ties it back to the originating component.
- For example, a request might generate:
    - A span at the gateway.
    - A span in the application layer.
    - Additional spans when interacting with user services or databases.
- These spans combine to form a complete trace of the request, providing a granular view of the interactions that occurred.

## Metrics
- Metrics offer quantifiable measurements that reflect the state of a system. 
- Unlike logs, which capture textual data, metrics deliver **numerical data** such as CPU load, the number of open files, HTTP response times, error counts, etc. 
- These measurements can be aggregated over time and visualized, making it easier to detect trends and identify anomalies.
- A typical metric entry might include:
    - A **metric name** that describes the measurement.
    - A **value** representing the current or recent reading.
    - A **timestamp** indicating when the metric was recorded.
    - Optional **dimensions** to provide additional context.
```bash
node_filesystem_avail_bytes{fstype="vfat", mountpoint="/home"} 5000 4:30AM 12/1/22
<name>                      <dimensions>                       <value> <timestamp>
```

[!NOTE] 
Prometheus is a monitoring solution that is responsible for collecting and aggregating metrics
